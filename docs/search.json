[
  {
    "objectID": "02.python-basics.html",
    "href": "02.python-basics.html",
    "title": "2  Python Language Basics, IPython, and Jupyter Notebooks",
    "section": "",
    "text": "2.1 The Python Interpreter (Python 解释器)\nPython 是一种解释型（interpreted）语言。Python 解释器通过一次执行一条语句来运行程序。可以使用 python 命令在命令行上调用标准交互式 Python 解释器：\n您看到的 &gt;&gt;&gt; 是提示符，您可以在该提示符后键入代码表达式。要退出 Python 解释器，您可以键入 exit() 或按 Ctrl-D（仅适用于 Linux 和 macOS）。\n运行 Python 程序就像使用 .py 文件作为第一个参数调用 python 一样简单。假设我们使用以下内容创建了 hello_world.py：\n您可以通过执行以下命令来运行它（hello_world.py 文件必须位于您当前的工作终端目录中）：\n虽然一些 Python 程序员以这种方式执行所有 Python 代码，但进行数据分析或科学计算的程序员则使用 IPython（一种增强的 Python 解释器）或 Jupyter notebooks（最初在 IPython 项目中创建的基于 Web 的代码笔记本）。我在本章中介绍了如何使用 IPython 和 Jupyter，并在 Appendix A: Advanced NumPy 中更深入地了解了 IPython 功能。当您使用 %run 命令时，IPython 会在同一进程中执行指定文件中的代码，使您能够在完成后以交互方式探索结果：\n与标准的 &gt;&gt;&gt; 提示符相比，默认的 IPython 提示符采用编号 In [2]: 样式。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Language Basics, IPython, and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "02.python-basics.html#the-python-interpreter-python-解释器",
    "href": "02.python-basics.html#the-python-interpreter-python-解释器",
    "title": "2  Python Language Basics, IPython, and Jupyter Notebooks",
    "section": "",
    "text": "$ python\nPython 3.10.4 | packaged by conda-forge | (main, Mar 24 2022, 17:38:57)\n[GCC 10.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; print(a)\n5\n\n\nprint(\"Hello world\")\n\n$ python hello_world.py\nHello world\n\n$ ipython\nPython 3.10.4 | packaged by conda-forge | (main, Mar 24 2022, 17:38:57)\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.31.1 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: %run hello_world.py\nHello world\n\nIn [2]:",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Language Basics, IPython, and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "01.preliminaries.html",
    "href": "01.preliminaries.html",
    "title": "1  Preliminaries",
    "section": "",
    "text": "1.1 What Is This Book About?\n本书涉及用 Python 操作、处理、清理和处理数据的具体细节。本书的目标是提供有关 Python 编程语言及其面向数据的库生态系统和工具的指南，帮助您成为一名高效的数据分析师。虽然本书的标题是“data analysis”，但重点是 Python 编程、库和工具，而不是数据分析方法。这是数据分析所需的 Python 编程。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preliminaries</span>"
    ]
  },
  {
    "objectID": "02.python-basics.html#ipython-basics",
    "href": "02.python-basics.html#ipython-basics",
    "title": "2  Python Language Basics, IPython, and Jupyter Notebooks",
    "section": "2.2 IPython Basics",
    "text": "2.2 IPython Basics\n在本节中，我将帮助您启动并运行 IPython shell 和 Jupyter Notebook，并向您介绍一些基本概念。\n\n2.2.1 Running the IPython Shell\n您可以在命令行上启动 IPython shell，就像启动常规 Python 解释器一样，只不过使用 ipython 命令：\n$ ipython\nPython 3.10.4 | packaged by conda-forge | (main, Mar 24 2022, 17:38:57)\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.31.1 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: a = 5\n\nIn [2]: a\nOut[2]: 5\n您可以通过键入任意 Python 语句并按 Return（或 Enter）来执行它们。当您在 IPython 中键入一个变量时，它会呈现该对象的字符串表示形式：\nIn [5]: import numpy as np\n\nIn [6]: data = [np.random.standard_normal() for i in range(7)]\n\nIn [7]: data\nOut[7]: \n[-0.20470765948471295,\n 0.47894333805754824,\n -0.5194387150567381,\n -0.55573030434749,\n 1.9657805725027142,\n 1.3934058329729904,\n 0.09290787674371767]\n前两行是 Python 代码语句；第二条语句创建一个名为 data 的变量，该变量引用新创建的列表。最后一行在控制台中打印 data 的值。\n许多类型的 Python 对象都被格式化为更具可读性或打印更美观，这与普通的 print 打印不同。如果你在标准 Python 解释器中打印上面的 data 变量，它的可读性会低得多：\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; data = [np.random.standard_normal() for i in range(7)]\n&gt;&gt;&gt; print(data)\n&gt;&gt;&gt; data\n[-0.5767699931966723, -0.1010317773535111, -1.7841005313329152,\n-1.524392126408841, 0.22191374220117385, -1.9835710588082562,\n-1.6081963964963528]\nIPython 还提供了执行任意代码块（通过某种美化的复制粘贴方法）和整个 Python 脚本的工具。您还可以使用 Jupyter notebook 来处理更大的代码块，我们很快就会看到。\n\n\n2.2.2 Running the Jupyter Notebook\nJupyter 项目的主要组件之一是 notebook，一种用于代码、文本（包括 Markdown）、数据可视化和其他输出的交互式文档。Jupyter notebook 与 kernels 交互，kernels 是特定于不同编程语言的 Jupyter 交互式计算协议的实现。Python Jupyter kernel 使用 IPython 系统来实现其底层行为。\n要启动 Jupyter，请在终端中运行命令 jupyter notebook：\n$ jupyter notebook\n[I 15:20:52.739 NotebookApp] Serving notebooks from local directory:\n/home/wesm/code/pydata-book\n[I 15:20:52.739 NotebookApp] 0 active kernels\n[I 15:20:52.739 NotebookApp] The Jupyter Notebook is running at:\nhttp://localhost:8888/?token=0a77b52fefe52ab83e3c35dff8de121e4bb443a63f2d...\n[I 15:20:52.740 NotebookApp] Use Control-C to stop this server and shut down\nall kernels (twice to skip confirmation).\nCreated new window in existing browser session.\n    To access the notebook, open this file in a browser:\n        file:///home/wesm/.local/share/jupyter/runtime/nbserver-185259-open.html\n    Or copy and paste one of these URLs:\n        http://localhost:8888/?token=0a77b52fefe52ab83e3c35dff8de121e4...\n     or http://127.0.0.1:8888/?token=0a77b52fefe52ab83e3c35dff8de121e4...\n在许多平台上，Jupyter 将自动在您的默认 Web 浏览器中打开（除非您使用 --no-browser 启动它）。否则，您可以导航到启动笔记本时打印的 HTTP 地址，此处为 http://localhost:8888/?token=0a77b52fefe52ab83e3c35dff8de121e4bb443a63f2d3055。请参阅 Figure 2.1 了解 Google Chrome 中的情况。\n\n\n\n\n\n\nNote\n\n\n\n很多人使用 Jupyter 作为本地计算环境，但它也可以部署在服务器上并远程访问。我不会在这里介绍这些细节，但我鼓励您在互联网上探索这个主题（如果它与您的需求相关）。\n\n\n\n\n\nFigure 2.1: Jupyter notebook landing page\n\n\n要创建新的笔记本，请单击“新建”按钮并选择“Python 3”选项。您应该看到如 Figure 2.2 所示的内容。如果这是您第一次，请尝试单击空代码“单元格”并输入一行 Python 代码。然后按 Shift-Enter 执行它。\n\n\n\nFigure 2.2: Jupyter new notebook view\n\n\n保存笔记本时（see “Save and Checkpoint” under the notebook File menu），它会创建一个扩展名为 .ipynb 的文件。这是一种独立的文件格式，包含当前笔记本中的所有内容（包括任何评估的代码输出）。其他 Jupyter 用户可以加载和编辑它们。\n要重命名打开的笔记本，请单击页面顶部的笔记本标题并键入新标题，完成后按 Enter。\n要加载现有笔记本，请将文件放在启动笔记本进程的同一目录中（或其中的子文件夹中），然后单击登录页面中的名称。您可以使用我在 GitHub 上的 wesm/pydata-book 存储库中的笔记本进行尝试。参见 Figure 2.3。\n当您想要关闭笔记本时，请单击 File 菜单并选择 “Close and Halt”。如果您只是关闭浏览器选项卡，与笔记本关联的 Python 进程将继续在后台运行。\n虽然 Jupyter Notebook 可能给人一种与 IPython shell 截然不同的体验，但本章中的几乎所有命令和工具都可以在任一环境中使用。\n\n\n\nFigure 2.3: Jupyter example view for an existing notebook\n\n\n\n\n2.2.3 Tab Completion\n从表面上看，IPython shell 看起来像是标准终端 Python 解释器（使用 python 调用）的一个外观上不同的版本。相对于标准 Python shell 的主要改进之一是制表符补全，在许多 IDEs 或其他交互式计算分析环境中都可以找到。在 shell 中输入表达式时，按 Tab 键将在命名空间中搜索与您目前键入的字符相匹配的任何变量（对象、函数等），并在方便的下拉菜单中显示结果：\nIn [1]: an_apple = 27\n\nIn [2]: an_example = 42\n\nIn [3]: an&lt;Tab&gt;\nan_apple   an_example  any\n在此示例中，请注意 IPython 显示了我定义的两个变量以及内置函数 any。此外，您还可以在输入句点后完成任何对象的方法和属性：\nIn [3]: b = [1, 2, 3]\n\nIn [4]: b.&lt;Tab&gt;\nappend()  count()   insert()  reverse()\nclear()   extend()  pop()     sort()\ncopy()    index()   remove()\n对于模块也是如此：\nIn [1]: import datetime\n\nIn [2]: datetime.&lt;Tab&gt;\ndate          MAXYEAR       timedelta\ndatetime      MINYEAR       timezone\ndatetime_CAPI time          tzinfo\n\n\n\n\n\n\nNote\n\n\n\n请注意，IPython 默认隐藏以下划线开头的方法和属性，例如 magic 方法和内部“私有（private）”方法和属性，以避免显示混乱（并使新手用户感到困惑！）。这些也可以通过制表符完成，但您必须首先键入下划线才能看到它们。如果您希望始终在制表符补全中看到此类方法，则可以在 IPython 配置中更改此设置。请参阅 IPython documentation 以了解如何执行此操作。\n\n\n除了搜索交互式命名空间和完成对象或模块属性之外，选项卡补全还可以在许多上下文中使用。当输入任何看起来像文件路径的内容时（即使是 Python 字符串），按 Tab 键将完成计算机文件系统上与您输入的内容匹配的任何内容。\n与 %run 命令（请参阅 Appendix B.2.1: The %run Command）结合使用，此功能可以节省您许多击键次数。\n制表符补全可以节省时间的另一个方面是函数关键字参数的补全（包括 = 符号！）。参见 Figure 2.4。\n\n\n\nFigure 2.4: Autocomplete function keywords in a Jupyter notebook\n\n\n稍后我们将更仔细地了解函数。\n\n\n2.2.4 Introspection\n在变量之前或之后使用问号 (?) 将显示有关该对象的一些常规信息：\nIn [1]: b = [1, 2, 3]\n\nIn [2]: b?\nType:        list\nString form: [1, 2, 3]\nLength:      3\nDocstring:\nBuilt-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.\n\nIn [3]: print?\nDocstring:\nprint(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream.\nType:      builtin_function_or_method\n这称为对象自省（introspection）。如果对象是函数或实例方法，则还将显示文档字符串（如果已定义）。假设我们编写了以下函数（您可以在 IPython 或 Jupyter 中重现）：\ndef add_numbers(a, b):\n    \"\"\"\n    Add two numbers together\n\n    Returns\n    -------\n    the_sum : type of arguments\n    \"\"\"\n    return a + b\n然后使用 ? 向我们展示了文档字符串：\nIn [6]: add_numbers?\nSignature: add_numbers(a, b)\nDocstring:\nAdd two numbers together\nReturns\n-------\nthe_sum : type of arguments\nFile:      &lt;ipython-input-9-6a548a216e27&gt;\nType:      function\n?还有最后一个用途，即以类似于标准 Unix 或 Windows 命令行的方式搜索 IPython 命名空间。多个字符与通配符 (*) 组合将显示与通配符表达式匹配的所有名称。例如，我们可以获得顶级 NumPy 命名空间中包含 load 的所有函数的列表：\nIn [9]: import numpy as np\n\nIn [10]: np.*load*?\nnp.__loader__\nnp.load\nnp.loads\nnp.loadtxt",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Language Basics, IPython, and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python for Data Analysis, 3E",
    "section": "",
    "text": "About\n本书为《Python for Data Analysis》的中文翻译版本，仅供个人学习。\n原书链接：https://wesmckinney.com/book",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "02.python-basics.html#python-language-basics",
    "href": "02.python-basics.html#python-language-basics",
    "title": "2  Python Language Basics, IPython, and Jupyter Notebooks",
    "section": "2.3 Python Language Basics",
    "text": "2.3 Python Language Basics\n在本节中，我将概述基本的 Python 编程概念和语言机制。在下一章中，我将更详细地介绍 Python 数据结构、函数和其他内置工具。\n\n2.3.1 Language Semantics\nPython 语言设计的特点是强调可读性、简单性和明确性。有些人甚至将其比作“可执行伪代码（executable pseudocode）”。\nIndentation, not braces（缩进，而不是大括号）\nPython 使用空格（制表符或空格）来构建代码，而不是像 R、C++、Java 和 Perl 等许多其他语言那样使用大括号。考虑排序算法中的 for 循环：\nfor x in array:\n    if x &lt; pivot:\n        less.append(x)\n    else:\n        greater.append(x)\n冒号表示缩进代码块的开始，之后所有代码都必须缩进相同的量，直到块的末尾。\n不管你喜欢还是讨厌，重要的空格对于 Python 程序员来说都是一个事实。虽然一开始它可能看起来很陌生，但希望您很快就会习惯它。\n\n\n\n\n\n\nNote\n\n\n\n我强烈建议使用四个空格作为默认缩进，并将制表符替换为四个空格。许多文本编辑器都有一个设置，可以自动用空格替换制表位（这样做！）。IPython 和 Jupyter notebooks 将自动在冒号后面的新行中插入四个空格，并将制表符替换为四个空格。\n\n\n正如您现在所看到的，Python 语句也不需要以分号终止。但是，可以使用分号来分隔一行上的多个语句：\na = 5; b = 6; c = 7\n在 Python 中通常不鼓励将多个语句放在一行上，因为这会降低代码的可读性。\nEverything is an object（一切皆对象）\nPython 语言的一个重要特性是其对象模型的一致性。每个数字、字符串、数据结构、函数、类、模块等都存在于 Python 解释器中自己的“盒子”中，称为 Python object。每个对象都有一个关联的类型（例如整数、字符串或函数）和内部数据。实际上，这使得该语言非常灵活，因为甚至函数也可以像任何其他对象一样对待。\nComments（注释）\nPython 解释器会忽略任何以井号 # 开头的文本。这通常用于向代码添加注释。有时您可能还想排除某些代码块而不删除它们。一种解决方案是注释掉代码：\nresults = []\nfor line in file_handle:\n    # keep the empty lines for now\n    # if len(line) == 0:\n    #   continue\n    results.append(line.replace(\"foo\", \"bar\"))\n注释也可以出现在执行代码行之后。虽然有些程序员喜欢将注释放在特定代码行的前面，但这有时很有用：\nprint(\"Reached this line\")  # Simple status report\nFunction and object method calls（函数和对象方法调用）\n您可以使用括号并传递零个或多个参数来调用函数，还可以选择将返回值分配给变量：\nresult = f(x, y, z)\ng()\nPython 中几乎每个对象都具有附加函数（称为方法），可以访问对象的内部内容。您可以使用以下语法来调用它们：\nobj.some_method(x, y, z)\n函数可以同时采用位置参数和关键字参数：\nresult = f(a, b, c, d=5, e=\"foo\")\n稍后我们将更详细地讨论这一点。\nVariables and argument passing（变量和参数传递）\n在 Python 中分配变量（或名称）时，您正在创建对等号右侧显示的对象的引用。实际上，考虑一个整数列表：\nIn [8]: a = [1, 2, 3]\n假设我们将 a 赋给一个新变量 b：\nIn [9]: b = a\n\nIn [10]: b\nOut[10]: [1, 2, 3]\n在某些语言中，如果 b 的赋值会导致数据 [1, 2, 3] 被复制。在 Python 中，a 和 b 现在实际上指的是同一个对象，即原始列表 [1, 2, 3]（参见 Figure 2.5 的模型）。您可以通过将一个元素附加到 a 然后检查 b 来向自己证明这一点：\nIn [11]: a.append(4)\n\nIn [12]: b\nOut[12]: [1, 2, 3, 4]\n\n\n\nFigure 2.5: Two references for the same object\n\n\n当您在 Python 中处理较大的数据集时，了解 Python 中引用的语义以及复制数据的时间、方式和原因尤其重要。\n\n\n\n\n\n\nNote\n\n\n\n赋值（Assignment）也称为绑定（binding），因为我们将名称绑定到对象。已分配的变量名称有时可能称为绑定变量。\n\n\n当您将对象作为参数传递给函数时，将创建引用原始对象的新局部变量，而不进行任何复制。如果将新对象绑定到函数内部的变量，则不会覆盖函数外部“范围(scope)”（“父范围(parent scope)”）中的同名变量。因此，可以改变可变参数的内部结构。假设我们有以下函数：\nIn [13]: def append_element(some_list, element):\n   ....:     some_list.append(element)\n然后我们有：\nIn [14]: data = [1, 2, 3]\n\nIn [15]: append_element(data, 4)\n\nIn [16]: data\nOut[16]: [1, 2, 3, 4]\nDynamic references, strong types（动态引用、强类型）\nPython 中的变量没有与其关联的固有类型；只需进行赋值，变量就可以引用不同类型的对象。以下情况是没有问题的：\nIn [17]: a = 5\n\nIn [18]: type(a)\nOut[18]: int\n\nIn [19]: a = \"foo\"\n\nIn [20]: type(a)\nOut[20]: str\n变量是特定命名空间中对象的名称；类型信息存储在对象本身中。一些观察者可能会仓促得出结论：Python 不是一种“类型化语言”。这不是真的；考虑这个例子：\nIn [21]: \"5\" + 5\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-21-7fe5aa79f268&gt; in &lt;module&gt;\n----&gt; 1 \"5\" + 5\nTypeError: can only concatenate str (not \"int\") to str\n在某些语言中，字符串 '5' 可能会隐式转换为整数，从而生成 10。在其他语言中，整数 5 可能会转换为字符串，生成连接字符串 '55'。在 Python 中，不允许这种隐式转换。就此而言，我们说 Python 是一种强类型（strongly typed）语言，这意味着每个对象都有特定的类型（或类），并且只有在某些允许的情况下才会发生隐式转换，例如：\nIn [22]: a = 4.5\n\nIn [23]: b = 2\n\n# String formatting, to be visited later\nIn [24]: print(f\"a is {type(a)}, b is {type(b)}\")\na is &lt;class 'float'&gt;, b is &lt;class 'int'&gt;\n\nIn [25]: a / b\nOut[25]: 2.25\n这里，即使 b 是整数，它也会被隐式转换为浮点数以进行除法运算。\n了解对象的类型很重要，并且能够编写可以处理多种不同类型输入的函数非常有用。您可以使用 isinstance 函数检查对象是否是特定类型的实例：\nIn [26]: a = 5\n\nIn [27]: isinstance(a, int)\nOut[27]: True\n如果您想检查对象的类型是否属于元组中存在的类型，则 isinstance 可以接受类型元组：\nIn [28]: a = 5; b = 4.5\n\nIn [29]: isinstance(a, (int, float))\nOut[29]: True\n\nIn [30]: isinstance(b, (int, float))\nOut[30]: True\nAttributes and methods（属性和方法）\nPython 中的对象通常具有属性（存储在对象“内部”的其他 Python 对象）和方法（与对象关联的可以访问对象内部数据的函数）。它们都可以通过语法 &lt;obj.attribute_name&gt; 访问：\nIn [1]: a = \"foo\"\n\nIn [2]: a.&lt;Press Tab&gt;\ncapitalize() index()        isspace()      removesuffix()  startswith()\ncasefold()   isprintable()  istitle()      replace()       strip()\ncenter()     isalnum()      isupper()      rfind()         swapcase()\ncount()      isalpha()      join()         rindex()        title()\nencode()     isascii()      ljust()        rjust()         translate()\nendswith()   isdecimal()    lower()        rpartition()\nexpandtabs() isdigit()      lstrip()       rsplit()\nfind()       isidentifier() maketrans()    rstrip()\nformat()     islower()      partition()    split()\nformat_map() isnumeric()    removeprefix() splitlines()\n属性和方法也可以通过 getattr 函数按名称访问：\nIn [32]: getattr(a, \"split\")\nOut[32]: &lt;function str.split(sep=None, maxsplit=-1)&gt;\n虽然我们不会在本书中广泛使用函数 getattr 以及相关函数 hasattr 和 setattr，但它们可以非常有效地用于编写通用的、可重用的代码。\nDuck typing（鸭子类型）\n通常，您可能不关心对象的类型，而只关心它是否具有某些方法或行为。这有时被称为鸭子类型，俗话说“如果它像鸭子一样行走并且像鸭子一样嘎嘎叫，那么它就是一只鸭子”。例如，如果一个对象实现了迭代器协议（iterator protocol），您可以验证该对象是否可迭代。对于许多对象来说，这意味着它有一个 __iter__ “魔术方法（magic method）”，尽管另一种更好的检查方法是尝试使用 iter 函数：\nIn [33]: def isiterable(obj):\n   ....:     try:\n   ....:         iter(obj)\n   ....:         return True\n   ....:     except TypeError: # not iterable\n   ....:         return False\n对于字符串以及大多数 Python 集合类型，此函数将返回 True：\nIn [34]: isiterable(\"a string\")\nOut[34]: True\n\nIn [35]: isiterable([1, 2, 3])\nOut[35]: True\n\nIn [36]: isiterable(5)\nOut[36]: False\nImports\n在 Python 中，模块只是一个包含 Python 代码、扩展名为 .py 的文件。假设我们有以下模块：\n# some_module.py\nPI = 3.14159\n\ndef f(x):\n    return x + 2\n\ndef g(a, b):\n    return a + b\n如果我们想从同一目录中的另一个文件访问 some_module.py 中定义的变量和函数，我们可以这样做：\nimport some_module\nresult = some_module.f(5)\npi = some_module.PI\n或者：\nfrom some_module import g, PI\nresult = g(5, PI)\n通过使用 as 关键字，您可以为导入指定不同的变量名称：\nimport some_module as sm\nfrom some_module import PI as pi, g as gf\n\nr1 = sm.f(pi)\nr2 = gf(6, pi)\nBinary operators and comparisons（二元运算符和比较）\n大多数二元数学运算和比较都使用其他编程语言中使用的熟悉的数学语法：\nIn [37]: 5 - 7\nOut[37]: -2\n\nIn [38]: 12 + 21.5\nOut[38]: 33.5\n\nIn [39]: 5 &lt;= 2\nOut[39]: False\n有关所有可用的二元运算符，请参阅 Table 2.1。\n\nTable 2.1: Binary operators\n\n\n\n\n\n\nOperation\nDescription\n\n\n\n\na + b\na 加 b\n\n\na - b\na 减 b\n\n\na * b\na 乘 b\n\n\na / b\na 除 b\n\n\na // b\na 除 b 后取整\n\n\na ** b\na 的 b 次方\n\n\na & b\n如果 a 和 b 都为 True，则为 True；对于整数，采用按位 AND\n\n\na | b\n如果 a 或 b 为 True，则为 True；对于整数，采用按位 OR\n\n\na ^ b\n对于布尔值，如果 a 或 b 为 True，但不是两者都为 True，则为 True；对于整数，采用按位 EXCLUSIVE-OR\n\n\na == b\n如果 a 等于 b，则为 True\n\n\na != b\n如果 a 不等于 b，则为 True\n\n\na &lt; b, a &lt;= b\n如果 a 小于（小于或等于）b，则为 True\n\n\na &gt; b, a &gt;= b\n如果 a 大于（大于或等于）b，则为 True\n\n\na is b\n如果 a 和 b 引用同一个 Python 对象，则为 True\n\n\na is not b\n如果 a 和 b 引用不同的 Python 对象，则为 True\n\n\n\n要检查两个变量是否引用同一个对象，请使用 is 关键字。使用 is not 检查两个对象是否不相同：\nIn [40]: a = [1, 2, 3]\n\nIn [41]: b = a\n\nIn [42]: c = list(a)\n\nIn [43]: a is b\nOut[43]: True\n\nIn [44]: a is not c\nOut[44]: True\n由于 list 函数总是创建一个新的 Python 列表（即副本），因此我们可以确定 c 与 a 不同。使用 is 进行比较与 == 运算符不同，因为在这种情况下我们有：\nIn [45]: a == c\nOut[45]: True\nis 和 is not 的一种常见用途是检查变量是否为 None，因为 None 仅有一个实例：\nIn [46]: a = None\n\nIn [47]: a is None\nOut[47]: True\nMutable and immutable objects（可变和不可变对象）\nPython 中的许多对象，例如列表、字典、NumPy 数组和大多数用户定义的类型（类），都是可变的。这意味着可以修改它们包含的对象或值：\nIn [48]: a_list = [\"foo\", 2, [4, 5]]\n\nIn [49]: a_list[2] = (3, 4)\n\nIn [50]: a_list\nOut[50]: ['foo', 2, (3, 4)]\n其他的，如字符串和元组，是不可变的，这意味着它们的内部数据不能更改：\nIn [51]: a_tuple = (3, 5, (4, 5))\n\nIn [52]: a_tuple[1] = \"four\"\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-52-cd2a018a7529&gt; in &lt;module&gt;\n----&gt; 1 a_tuple[1] = \"four\"\nTypeError: 'tuple' object does not support item assignment\n请记住，仅仅因为您可以改变对象并不意味着您总是应该这样做。此类行为称为副作用。例如，在编写函数时，应在函数的文档或注释中明确向用户传达任何副作用。如果可能的话，我建议尝试避免副作用并支持不变性，即使可能涉及可变对象。\n\n\n2.3.2 Scalar Types\nPython 有一小部分内置类型用于处理数值数据、字符串、布尔值（True 或 False）以及日期和时间。这些“单值（single value）”类型有时称为标量类型（scalar types），我们在本书中将它们称为标量（scalars）。有关主要标量类型的列表，请参阅 Table 2.2。日期和时间处理将单独讨论，因为它们是由标准库中的 datetime 模块提供的。\n\nTable 2.2: Standard Python scalar types\n\n\nType\nDescription\n\n\n\n\nNone\nPython “null” 值（None 对象仅存在一个实例）\n\n\nstr\n字符串类型；保存 Unicode 字符串\n\n\nbytes\n原始二进制数据\n\n\nfloat\n双精度浮点数（注意没有单独的 double 类型）\n\n\nbool\n布尔 True 或 False 值\n\n\nint\n任意精度整数\n\n\n\nNumeric types\nPython 中数字的主要类型是 int 和 float。int 可以存储任意大的数字：\nIn [53]: ival = 17239871\n\nIn [54]: ival ** 6\nOut[54]: 26254519291092456596965462913230729701102721\n浮点数用 Python float 类型表示。在底层，每一个都是一个双精度值。它们也可以用科学计数法来表示：\nIn [55]: fval = 7.243\n\nIn [56]: fval2 = 6.78e-5\n不产生整数的整数除法将始终产生浮点数：\nIn [57]: 3 / 2\nOut[57]: 1.5\n要获得 C-style 的整数除法（如果结果不是整数，则舍去小数部分），请使用向下取整除法运算符 //：\nIn [58]: 3 // 2\nOut[58]: 1\nStrings\n许多人使用 Python 是因为它内置的字符串处理功能。您可以使用单引号 ' 或双引号 \" 编写字符串文字（通常首选双引号）：\na = 'one way of writing a string'\nb = \"another way\"\nPython 的字符串类型是 str。\n对于带有换行符的多行字符串，您可以使用三引号，即 ''' 或 \"\"\"：\nc = \"\"\"\nThis is a longer string that\nspans multiple lines\n\"\"\"\n您可能会惊讶这个字符串 c 实际上包含四行文本； \"\"\" 之后的换行符和 lines 之后都包含在字符串中。我们可以使用 c 上的 count 方法来计算新行字符：\nIn [60]: c.count(\"\\n\")\nOut[60]: 3\nPython 字符串是不可变的；你不能修改字符串：\nIn [61]: a = \"this is a string\"\n\nIn [62]: a[10] = \"f\"\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-62-3b2d95f10db4&gt; in &lt;module&gt;\n----&gt; 1 a[10] = \"f\"\nTypeError: 'str' object does not support item assignment\n要解释此错误消息，请从下往上阅读。我们尝试将位置 10 处的字符（“item”）替换为字母\"f\"，但这对于字符串对象是不允许的。如果我们需要修改字符串，我们必须使用创建新字符串的函数或方法，例如字符串 replace 方法：\nIn [63]: b = a.replace(\"string\", \"longer string\")\n\nIn [64]: b\nOut[64]: 'this is a longer string'\n执行此操作后，变量 a 未修改：\nIn [65]: a\nOut[65]: 'this is a string'\n许多 Python 对象可以使用 str 函数转换为字符串：\nIn [66]: a = 5.6\n\nIn [67]: s = str(a)\n\nIn [68]: print(s)\n5.6\n字符串是 Unicode 字符序列，因此可以像其他序列（例如列表和元组）一样对待：\nIn [69]: s = \"python\"\n\nIn [70]: list(s)\nOut[70]: ['p', 'y', 't', 'h', 'o', 'n']\n\nIn [71]: s[:3]\nOut[71]: 'pyt'\n语法 s[:3] 称为切片（slicing），并为多种 Python 序列实现。稍后将对此进行更详细的解释，因为它在本书中被广泛使用。\n反斜杠字符 \\ 是转义字符，这意味着它用于指定特殊字符，例如换行符 \\n 或 Unicode 字符。要编写带有反斜杠的字符串文字，您需要对它们进行转义：\nIn [72]: s = \"12\\\\34\"\n\nIn [73]: print(s)\n12\\34\n如果您的字符串包含很多反斜杠并且没有特殊字符，您可能会发现这有点烦人。幸运的是，您可以在字符串的前导引号前添加 r，这意味着字符应按原样解释：\nIn [74]: s = r\"this\\has\\no\\special\\characters\"\n\nIn [75]: s\nOut[75]: 'this\\\\has\\\\no\\\\special\\\\characters'\nr 代表原始（raw）。\n将两个字符串相加会将它们连接起来并生成一个新字符串：\nIn [76]: a = \"this is the first half \"\n\nIn [77]: b = \"and this is the second half\"\n\nIn [78]: a + b\nOut[78]: 'this is the first half and this is the second half'\n字符串模板或格式化是另一个重要主题。随着 Python 3 的出现，实现此目的的方法数量不断增加，在这里我将简要描述其中一个主要接口的机制。字符串对象有一个 format 方法，可用于将格式化参数替换为字符串，生成一个新字符串：\nIn [79]: template = \"{0:.2f} {1:s} are worth US${2:d}\"\n在这个字符串中：\n\n{0:.2f} 表示将第一个参数格式化为具有两位小数的浮点数。\n{1:s} 表示将第二个参数格式化为字符串。\n{2:d} 表示将第三个参数格式化为精确整数。\n\n为了替换这些格式参数的参数，我们将一系列参数传递给 format 方法：\nIn [80]: template.format(88.46, \"Argentine Pesos\", 1)\nOut[80]: '88.46 Argentine Pesos are worth US$1'\nPython 3.6 引入了一个名为 f-strings（格式化字符串文字的缩写）的新功能，它可以使创建格式化字符串变得更加方便。要创建 f-strings，请在字符串文字前面写入字符 f。在字符串中，将 Python 表达式括在大括号中，以将表达式的值替换为格式化字符串：\nIn [81]: amount = 10\n\nIn [82]: rate = 88.46\n\nIn [83]: currency = \"Pesos\"\n\nIn [84]: result = f\"{amount} {currency} is worth US${amount / rate}\"\n可以使用与上面的字符串模板相同的语法在每个表达式之后添加格式说明符：\nIn [85]: f\"{amount} {currency} is worth US${amount / rate:.2f}\"\nOut[85]: '10 Pesos is worth US$0.11'\n字符串格式化是一个深奥的话题；有多种方法和大量选项和调整可用于控制结果字符串中值的格式。要了解更多信息，请查阅 official Python documentation。\nBytes and Unicode\n在现代 Python（即 Python 3.0 及更高版本）中，Unicode 已成为一流的字符串类型，可以更一致地处理 ASCII 和 non-ASCII 文本。在旧版本的 Python 中，字符串都是字节，没有任何显式的 Unicode 编码。假设您知道字符编码，则可以转换为 Unicode。下面是一个包含非 ASCII 字符的 Unicode 字符串示例：\nIn [86]: val = \"español\"\n\nIn [87]: val\nOut[87]: 'español'\n我们可以使用 encode 方法将此 Unicode 字符串转换为其 UTF-8 字节表示形式：\nIn [88]: val_utf8 = val.encode(\"utf-8\")\n\nIn [89]: val_utf8\nOut[89]: b'espa\\xc3\\xb1ol'\n\nIn [90]: type(val_utf8)\nOut[90]: bytes\n假设您知道 bytes 对象的 Unicode 编码，您可以使用 decode 方法返回：\nIn [91]: val_utf8.decode(\"utf-8\")\nOut[91]: 'español'\n虽然现在最好对任何编码使用 UTF-8，但由于历史原因，您可能会遇到多种不同编码的数据：\nIn [92]: val.encode(\"latin1\")\nOut[92]: b'espa\\xf1ol'\n\nIn [93]: val.encode(\"utf-16\")\nOut[93]: b'\\xff\\xfee\\x00s\\x00p\\x00a\\x00\\xf1\\x00o\\x00l\\x00'\n\nIn [94]: val.encode(\"utf-16le\")\nOut[94]: b'e\\x00s\\x00p\\x00a\\x00\\xf1\\x00o\\x00l\\x00'\n在处理文件的上下文中最常见的是遇到 bytes 对象，其中可能不需要将所有数据隐式解码为 Unicode 字符串。\nBooleans\nPython 中的两个布尔值分别写为 True 和 False。比较和其他条件表达式的计算结果为 True 或 False。布尔值与 and 和 or 关键字组合：\nIn [95]: True and True\nOut[95]: True\n\nIn [96]: False or True\nOut[96]: True\n转换为数字时，False 变为 0，True 变为 1：\nIn [97]: int(False)\nOut[97]: 0\n\nIn [98]: int(True)\nOut[98]: 1\n该关键字 not 会将布尔值从 True 翻转为 False，反之亦然：\nIn [99]: a = True\n\nIn [100]: b = False\n\nIn [101]: not a\nOut[101]: False\n\nIn [102]: not b\nOut[102]: True\nType casting\nstr、bool、int 和 float 类型也是可用于将值转换为这些类型的函数：\nIn [103]: s = \"3.14159\"\n\nIn [104]: fval = float(s)\n\nIn [105]: type(fval)\nOut[105]: float\n\nIn [106]: int(fval)\nOut[106]: 3\n\nIn [107]: bool(fval)\nOut[107]: True\n\nIn [108]: bool(0)\nOut[108]: False\n请注意，大多数非零值在转换为 bool 时会变为 True。\nNone\nNone 是 Python 空值类型：\nIn [109]: a = None\n\nIn [110]: a is None\nOut[110]: True\n\nIn [111]: b = 5\n\nIn [112]: b is not None\nOut[112]: True\nNone 也是函数参数的常见默认值：\ndef add_and_maybe_multiply(a, b, c=None):\n    result = a + b\n\n    if c is not None:\n        result = result * c\n\n    return result\nDates and times\n内置的 Python datetime 模块提供了 datetime、date 和 time 类型。datetime 类型结合了 date 和 time 存储的信息，最常用：\nIn [113]: from datetime import datetime, date, time\n\nIn [114]: dt = datetime(2011, 10, 29, 20, 30, 21)\n\nIn [115]: dt.day\nOut[115]: 29\n\nIn [116]: dt.minute\nOut[116]: 30\n给定一个 datetime 实例，您可以通过调用 datetime 上同名的方法来提取等效的 date 和 time 对象：\nIn [117]: dt.date()\nOut[117]: datetime.date(2011, 10, 29)\n\nIn [118]: dt.time()\nOut[118]: datetime.time(20, 30, 21)\nstrftime 方法将 datetime 格式化为字符串：\nIn [119]: dt.strftime(\"%Y-%m-%d %H:%M\")\nOut[119]: '2011-10-29 20:30'\n有关格式规范的完整列表，请参阅 Table 11.2。\n当您聚合或以其他方式对时间序列数据进行分组时，替换一系列日期时间的 datetime 字段有时会很有用，例如，将 minute 和 second 字段替换为零：\nIn [121]: dt_hour = dt.replace(minute=0, second=0)\n\nIn [122]: dt_hour\nOut[122]: datetime.datetime(2011, 10, 29, 20, 0)\n由于 datetime.datetime 是不可变类型，因此此类方法总是会生成新对象。所以在前面的例子中，dt 并没有被 replace 修改：\nIn [123]: dt\nOut[123]: datetime.datetime(2011, 10, 29, 20, 30, 21)\n两个 datetime 对象的差异产生 datetime.timedelta 类型：\nIn [124]: dt2 = datetime(2011, 11, 15, 22, 30)\n\nIn [125]: delta = dt2 - dt\n\nIn [126]: delta\nOut[126]: datetime.timedelta(days=17, seconds=7179)\n\nIn [127]: type(delta)\nOut[127]: datetime.timedelta\n输出 timedelta(17, 7179) 表示 timedelta 编码了 17 天 7,179 秒的偏移量。\n将 timedelta 添加到 datetime 会产生新的移位日期时间：\nIn [128]: dt\nOut[128]: datetime.datetime(2011, 10, 29, 20, 30, 21)\n\nIn [129]: dt + delta\nOut[129]: datetime.datetime(2011, 11, 15, 22, 30)\n\n\n2.3.3 Control Flow\nPython 有几个内置关键字，用于条件逻辑、循环和其他编程语言中的其他标准控制流概念。\nif, elif, and else\nif 语句是最著名的控制流语句类型之一。它检查一个条件，如果为 True，则评估后面块中的代码：\nx = -5\nif x &lt; 0:\n    print(\"It's negative\")\n如果所有条件都为 False，则 if 语句后面可以选择跟随一个或多个 elif 块以及一个包罗万象的 else 块：\nif x &lt; 0:\n    print(\"It's negative\")\nelif x == 0:\n    print(\"Equal to zero\")\nelif 0 &lt; x &lt; 5:\n    print(\"Positive but smaller than 5\")\nelse:\n    print(\"Positive and larger than or equal to 5\")\n如果任何条件为 True，则不会再到达 elif 或 else 块。对于使用 and 或 or 的复合条件，条件从左到右计算并且会短路：\nIn [130]: a = 5; b = 7\n\nIn [131]: c = 8; d = 4\n\nIn [132]: if a &lt; b or c &gt; d:\n   .....:     print(\"Made it\")\nMade it\n在此示例中，比较 c &gt; d 永远不会被计算，因为第一个比较为 True。\n也可以进行链式比较：\nIn [133]: 4 &gt; 3 &gt; 2 &gt; 1\nOut[133]: True\nfor loops\nfor 循环用于迭代集合（如列表或元组）或迭代器。for 循环的标准语法是：\nfor value in collection:\n    # do something with value\n您可以使用 continue 关键字将 for 循环推进到下一次迭代，跳过块的其余部分。考虑以下代码，它将列表中的整数相加并跳过 None 值：\nsequence = [1, 2, None, 4, None, 5]\ntotal = 0\nfor value in sequence:\n    if value is None:\n        continue\n    total += value\n可以使用 break 关键字一起退出 for 循环。此代码对列表中的元素求和，直到达到 5：\nsequence = [1, 2, 0, 4, 6, 5, 2, 1]\ntotal_until_5 = 0\nfor value in sequence:\n    if value == 5:\n        break\n    total_until_5 += value\nbreak 关键字仅终止最内层的 for 循环；任何外部 for 循环将继续运行：\nIn [134]: for i in range(4):\n   .....:     for j in range(4):\n   .....:         if j &gt; i:\n   .....:             break\n   .....:         print((i, j))\n   .....:\n(0, 0)\n(1, 0)\n(1, 1)\n(2, 0)\n(2, 1)\n(2, 2)\n(3, 0)\n(3, 1)\n(3, 2)\n(3, 3)\n正如我们将更详细地看到的，如果集合或迭代器中的元素是序列（例如元组或列表），则可以方便地将它们解包到 for 循环语句中的变量中：\nfor a, b, c in iterator:\n    # do something\nwhile loops\nwhile 循环指定一个条件和一个要执行的代码块，直到条件计算结果为 False 或循环以 break 显式结束：\nx = 256\ntotal = 0\nwhile x &gt; 0:\n    if total &gt; 500:\n        break\n    total += x\n    x = x // 2\npass\npass 是 Python 中的“no-op”（或“不执行任何操作”）语句。它可以用在不采取任何操作的块中（或者作为尚未实现的代码的占位符）；它是必需的，只是因为 Python 使用空格来分隔块：\nif x &lt; 0:\n    print(\"negative!\")\nelif x == 0:\n    # TODO: put something smart here\n    pass\nelse:\n    print(\"positive!\")\nrange\nrange 函数生成均匀间隔的整数序列：\nIn [135]: range(10)\nOut[135]: range(0, 10)\n\nIn [136]: list(range(10))\nOut[136]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n可以给出开始、结束和步骤（可能是负数）：\nIn [137]: list(range(0, 20, 2))\nOut[137]: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\nIn [138]: list(range(5, 0, -1))\nOut[138]: [5, 4, 3, 2, 1]\n正如您所看到的，range 生成直到但不包括端点的整数。range 的常见用途是按索引迭代序列：\nIn [139]: seq = [1, 2, 3, 4]\n\nIn [140]: for i in range(len(seq)):\n   .....:     print(f\"element {i}: {seq[i]}\")\nelement 0: 1\nelement 1: 2\nelement 2: 3\nelement 3: 4\n虽然您可以使用 list 等函数将 range 生成的所有整数存储在其他数据结构中，但通常默认的迭代器形式就是您想要的。此代码片段将 0 到 99,999 之间所有 3 或 5 的倍数的数字相加：\nIn [141]: total = 0\n\nIn [142]: for i in range(100_000):\n   .....:     # % is the modulo operator\n   .....:     if i % 3 == 0 or i % 5 == 0:\n   .....:         total += i\n\nIn [143]: print(total)\n2333316668\n虽然生成的范围可以任意大，但任何给定时间的内存使用量可能非常小。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Language Basics, IPython, and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "02.python-basics.html#conclusion",
    "href": "02.python-basics.html#conclusion",
    "title": "2  Python Language Basics, IPython, and Jupyter Notebooks",
    "section": "2.4 Conclusion",
    "text": "2.4 Conclusion\n本章简要介绍了一些基本的 Python 语言概念以及 IPython 和 Jupyter 编程环境。在下一章中，我将讨论许多内置数据类型、函数和输入输出实用程序，这些内容将在本书的其余部分中不断使用。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Python Language Basics, IPython, and Jupyter Notebooks</span>"
    ]
  },
  {
    "objectID": "03.python-builtin.html",
    "href": "03.python-builtin.html",
    "title": "3  Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "3.1 Data Structures and Sequences\nPython 的数据结构简单但功能强大。掌握它们的使用是成为熟练的 Python 程序员的关键部分。我们从元组、列表和字典开始，它们是一些最常用的序列类型。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Built-In Data Structures, Functions, and Files</span>"
    ]
  },
  {
    "objectID": "03.python-builtin.html#data-structures-and-sequences",
    "href": "03.python-builtin.html#data-structures-and-sequences",
    "title": "3  Built-In Data Structures, Functions, and Files",
    "section": "",
    "text": "3.1.1 Tuple\n元组（tuples）是固定长度、不可变的 Python 对象序列，一旦分配就无法更改。创建一个最简单的方法是使用括号中的逗号分隔值序列：\nIn [2]: tup = (4, 5, 6)\n\nIn [3]: tup\nOut[3]: (4, 5, 6)\n在许多情况下，括号可以省略，所以这里我们也可以写成：\nIn [4]: tup = 4, 5, 6\n\nIn [5]: tup\nOut[5]: (4, 5, 6)\n您可以通过调用 tuple 将任何序列或迭代器转换为元组：\nIn [6]: tuple([4, 0, 2])\nOut[6]: (4, 0, 2)\n\nIn [7]: tup = tuple('string')\n\nIn [8]: tup\nOut[8]: ('s', 't', 'r', 'i', 'n', 'g')\n与大多数其他序列类型一样，可以使用方括号 [] 访问元素。与 C、C++、Java 和许多其他语言一样，序列在 Python 中是从 0 索引的：\nIn [9]: tup[0]\nOut[9]: 's'\n当您在更复杂的表达式中定义元组时，通常需要将值括在括号中，如创建元组的元组的示例所示：\nIn [10]: nested_tup = (4, 5, 6), (7, 8)\n\nIn [11]: nested_tup\nOut[11]: ((4, 5, 6), (7, 8))\n\nIn [12]: nested_tup[0]\nOut[12]: (4, 5, 6)\n\nIn [13]: nested_tup[1]\nOut[13]: (7, 8)\n虽然存储在元组中的对象本身可能是可变的，但一旦创建元组，就无法修改每个槽中存储的对象：\nIn [14]: tup = tuple(['foo', [1, 2], True])\n\nIn [15]: tup[2] = False\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-15-b89d0c4ae599&gt; in &lt;module&gt;\n----&gt; 1 tup[2] = False\nTypeError: 'tuple' object does not support item assignment\n如果元组内的对象是可变的，例如列表，您可以就地修改它：\nIn [16]: tup[1].append(3)\n\nIn [17]: tup\nOut[17]: ('foo', [1, 2, 3], True)\n您可以使用 + 运算符连接元组以生成更长的元组：\nIn [18]: (4, None, 'foo') + (6, 0) + ('bar',)\nOut[18]: (4, None, 'foo', 6, 0, 'bar')\n与列表一样，将元组乘以整数会产生连接元组的多个副本的效果：\nIn [19]: ('foo', 'bar') * 4\nOut[19]: ('foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar')\n请注意，对象本身不会被复制，只会复制对它们的引用。\nUnpacking tuples（元组拆包）\n如果您尝试分配给类似元组的变量表达式，Python 将尝试拆包（unpack）等号右侧的值：\nIn [20]: tup = (4, 5, 6)\n\nIn [21]: a, b, c = tup\n\nIn [22]: b\nOut[22]: 5\n即使是带有嵌套元组的序列也可以被拆包：\nIn [23]: tup = 4, 5, (6, 7)\n\nIn [24]: a, b, (c, d) = tup\n\nIn [25]: d\nOut[25]: 7\n使用此功能，您可以轻松交换变量名称，这项任务在许多语言中可能如下所示：\ntmp = a\na = b\nb = tmp\n但是，在 Python 中，交换可以这样完成：\nIn [26]: a, b = 1, 2\n\nIn [27]: a\nOut[27]: 1\n\nIn [28]: b\nOut[28]: 2\n\nIn [29]: b, a = a, b\n\nIn [30]: a\nOut[30]: 2\n\nIn [31]: b\nOut[31]: 1\n变量拆包的常见用途是迭代元组或列表的序列：\nIn [32]: seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n\nIn [33]: for a, b, c in seq:\n   ....:     print(f'a={a}, b={b}, c={c}')\na=1, b=2, c=3\na=4, b=5, c=6\na=7, b=8, c=9\n另一个常见用途是从函数返回多个值。稍后我将更详细地介绍这一点。\n在某些情况下，您可能希望从元组的开头“提取”一些元素。有一种特殊的语法可以做到这一点，*rest，它也用在函数签名中来捕获任意长的位置参数列表：\nIn [34]: values = 1, 2, 3, 4, 5\n\nIn [35]: a, b, *rest = values\n\nIn [36]: a\nOut[36]: 1\n\nIn [37]: b\nOut[37]: 2\n\nIn [38]: rest\nOut[38]: [3, 4, 5]\n这个 rest 部分有时是你想要丢弃的东西；rest 名称没有什么特别的。按照惯例，许多 Python 程序员会使用下划线 (_) 来表示不需要的变量：\nIn [39]: a, b, *_ = values\nTuple methods\n由于元组的大小和内容无法修改，因此实例方法非常简单。一个特别有用的方法（也可用于列表）是 count，它计算某个值出现的次数：\nIn [40]: a = (1, 2, 2, 2, 3, 4, 2)\n\nIn [41]: a.count(2)\nOut[41]: 4\n\n\n3.1.2 List\n与元组相比，列表（lists）是可变长度的，并且可以就地修改其内容。列表是可变的。您可以使用方括号 [] 或使用 list 类型函数来定义它们：\nIn [42]: a_list = [2, 3, 7, None]\n\nIn [43]: tup = (\"foo\", \"bar\", \"baz\")\n\nIn [44]: b_list = list(tup)\n\nIn [45]: b_list\nOut[45]: ['foo', 'bar', 'baz']\n\nIn [46]: b_list[1] = \"peekaboo\"\n\nIn [47]: b_list\nOut[47]: ['foo', 'peekaboo', 'baz']\n列表和元组在语义上相似（尽管元组不能修改）并且可以在许多函数中互换使用。\nlist 内置函数在数据处理中经常使用，作为具体化迭代器或生成器表达式的一种方式：\nIn [48]: gen = range(10)\n\nIn [49]: gen\nOut[49]: range(0, 10)\n\nIn [50]: list(gen)\nOut[50]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nAdding and removing elements（添加和删​​除元素）\n可以使用 append 方法将元素追加到列表的末尾：\nIn [51]: b_list.append(\"dwarf\")\n\nIn [52]: b_list\nOut[52]: ['foo', 'peekaboo', 'baz', 'dwarf']\n使用 insert 可以在列表中的特定位置插入元素：\nIn [53]: b_list.insert(1, \"red\")\n\nIn [54]: b_list\nOut[54]: ['foo', 'red', 'peekaboo', 'baz', 'dwarf']\n插入索引必须介于 0 和列表长度（含）之间。\n\n\n\n\n\n\nWarning\n\n\n\n与 append 相比，insert 的计算成本较高，因为必须在内部移动对后续元素的引用，以便为新元素腾出空间。如果您需要在序列的开头和结尾插入元素，您可能希望探索 collections.deque，这是一个双端队列，它为此目的进行了优化，可以在 Python 标准库中找到。\n\n\ninsert 的逆操作是 pop，它删除并返回特定索引处的元素：\nIn [55]: b_list.pop(2)\nOut[55]: 'peekaboo'\n\nIn [56]: b_list\nOut[56]: ['foo', 'red', 'baz', 'dwarf']\n可以使用 remove 按值删除元素，它找到第一个这样的值并将其从列表中删除：\nIn [57]: b_list.append(\"foo\")\n\nIn [58]: b_list\nOut[58]: ['foo', 'red', 'baz', 'dwarf', 'foo']\n\nIn [59]: b_list.remove(\"foo\")\n\nIn [60]: b_list\nOut[60]: ['red', 'baz', 'dwarf', 'foo']\n如果性能不是问题，通过使用 append 和 remove，您可以使用 Python 列表作为类似集合的数据结构（尽管 Python 有实际的集合对象，稍后讨论）。\n使用 in 关键字检查列表是否包含值：\nIn [61]: \"dwarf\" in b_list\nOut[61]: True\n关键字 not 可用于否定 in：\nIn [62]: \"dwarf\" not in b_list\nOut[62]: False\n检查列表是否包含值比使用字典和集合（稍后介绍）慢很多，因为 Python 对列表的值进行线性扫描，而它可以检查其他值（基于哈希表）在恒定的时间内。\nConcatenating and combining lists（连接和组合列表）\n与元组类似，使用 + 将两个列表添加在一起将它们连接起来：\nIn [63]: [4, None, \"foo\"] + [7, 8, (2, 3)]\nOut[63]: [4, None, 'foo', 7, 8, (2, 3)]\n如果您已经定义了一个列表，则可以使用 extend 方法向其附加多个元素：\nIn [64]: x = [4, None, \"foo\"]\n\nIn [65]: x.extend([7, 8, (2, 3)])\n\nIn [66]: x\nOut[66]: [4, None, 'foo', 7, 8, (2, 3)]\n请注意，通过加法进行列表串联是一项相对昂贵的操作，因为必须创建新列表并复制对象。使用 extend 将元素追加到现有列表中，尤其是在构建大型列表时，通常更可取。因此：\neverything = []\nfor chunk in list_of_lists:\n    everything.extend(chunk)\n比串联替代方案更快：\neverything = []\nfor chunk in list_of_lists:\n    everything = everything + chunk\nSorting（排序）\n您可以通过调用其 sort 函数对列表进行就地排序（无需创建新对象）：\nIn [67]: a = [7, 2, 5, 1, 3]\n\nIn [68]: a.sort()\n\nIn [69]: a\nOut[69]: [1, 2, 3, 5, 7]\nsort 有一些偶尔会派上用场的选项。一是能够传递辅助排序键，即生成用于对对象进行排序的值的函数。例如，我们可以按字符串的长度对字符串集合进行排序：\nIn [70]: b = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\n\nIn [71]: b.sort(key=len)\n\nIn [72]: b\nOut[72]: ['He', 'saw', 'six', 'small', 'foxes']\n很快，我们将看到 sorted 函数，它可以生成一般序列的排序副本。\nSlicing（切片）\n您可以使用切片表示法来选择大多数序列类型的部分，其基本形式由传递给索引运算符 [] 的 start:stop 组成：\nIn [73]: seq = [7, 2, 3, 7, 5, 6, 0, 1]\n\nIn [74]: seq[1:5]\nOut[74]: [2, 3, 7, 5]\n切片也可以分配一个序列：\nIn [75]: seq[3:5] = [6, 3]\n\nIn [76]: seq\nOut[76]: [7, 2, 3, 6, 3, 6, 0, 1]\n虽然包含 start 索引处的元素，但不包含 stop 索引处的元素，因此结果中的元素数量为 stop - start。\nstart 或 stop 都可以省略，在这种情况下，它们分别默认为序列的开始和序列的结束：\nIn [77]: seq[:5]\nOut[77]: [7, 2, 3, 6, 3]\n\nIn [78]: seq[3:]\nOut[78]: [6, 3, 6, 0, 1]\n负索引相对于末尾对序列进行切片：\nIn [79]: seq[-4:]\nOut[79]: [3, 6, 0, 1]\n\nIn [80]: seq[-6:-2]\nOut[80]: [3, 6, 3, 6]\n切片语义需要一些时间来适应，特别是如果您来自 R 或 MATLAB。请参阅 Figure 3.1，了解使用正整数和负整数进行切片的有用说明。在图中，索引显示在“bin 边缘”，以帮助显示使用正索引或负索引开始和停止切片选择的位置。\n\n\n\nFigure 3.1: Illustration of Python slicing conventions\n\n\n还可以在第二个冒号之后使用步骤来获取所有其他元素：\nIn [81]: seq[::2]\nOut[81]: [7, 3, 3, 0]\n一个巧妙的用法是传递 -1，它具有反转列表或元组的有用效果：\nIn [82]: seq[::-1]\nOut[82]: [1, 0, 6, 3, 6, 3, 2, 7]\n\n\n3.1.3 Dictionary\n字典或 dict 可能是最重要的内置 Python 数据结构。在其他编程语言中，字典有时称为哈希映射或关联数组。字典存储键值对的集合，其中键和值是 Python 对象。每个键都与一个值相关联，以便在给定特定键的情况下可以方便地检索、插入、修改或删除值。创建字典的一种方法是使用大括号 {} 和冒号来分隔键和值：\nIn [83]: empty_dict = {}\n\nIn [84]: d1 = {\"a\": \"some value\", \"b\": [1, 2, 3, 4]}\n\nIn [85]: d1\nOut[85]: {'a': 'some value', 'b': [1, 2, 3, 4]}\n您可以使用与访问列表或元组元素相同的语法来访问、插入或设置元素：\nIn [86]: d1[7] = \"an integer\"\n\nIn [87]: d1\nOut[87]: {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n\nIn [88]: d1[\"b\"]\nOut[88]: [1, 2, 3, 4]\n您可以使用与检查列表或元组是否包含值相同的语法来检查字典是否包含键：\nIn [89]: \"b\" in d1\nOut[89]: True\n您可以使用 del 关键字或 pop 方法（同时返回值并删除键）来删除值：\nIn [90]: d1[5] = \"some value\"\n\nIn [91]: d1\nOut[91]: \n{'a': 'some value',\n 'b': [1, 2, 3, 4],\n 7: 'an integer',\n 5: 'some value'}\n\nIn [92]: d1[\"dummy\"] = \"another value\"\n\nIn [93]: d1\nOut[93]: \n{'a': 'some value',\n 'b': [1, 2, 3, 4],\n 7: 'an integer',\n 5: 'some value',\n 'dummy': 'another value'}\n\nIn [94]: del d1[5]\n\nIn [95]: d1\nOut[95]: \n{'a': 'some value',\n 'b': [1, 2, 3, 4],\n 7: 'an integer',\n 'dummy': 'another value'}\n\nIn [96]: ret = d1.pop(\"dummy\")\n\nIn [97]: ret\nOut[97]: 'another value'\n\nIn [98]: d1\nOut[98]: {'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\nkeys 和 values 方法分别为您提供字典的键和值的迭代器。键的顺序取决于它们的插入顺序，这些函数以相同的顺序输出键和值：\nIn [99]: list(d1.keys())\nOut[99]: ['a', 'b', 7]\n\nIn [100]: list(d1.values())\nOut[100]: ['some value', [1, 2, 3, 4], 'an integer']\n如果需要迭代键和值，可以使用 items 方法将键和值作为 2-元组进行迭代：\nIn [101]: list(d1.items())\nOut[101]: [('a', 'some value'), ('b', [1, 2, 3, 4]), (7, 'an integer')]\n您可以使用 update 方法将一个字典合并到另一个字典中：\nIn [102]: d1.update({\"b\": \"foo\", \"c\": 12})\n\nIn [103]: d1\nOut[103]: {'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}\nupdate 方法会就地更改字典，因此传递给 update 的数据中的任何现有键都将丢弃其旧值。\nCreating dictionaries from sequences（从序列创建字典）\n偶尔会出现想要在字典中按元素配对的两个序列，这是很常见的。作为第一步，您可能会编写如下代码：\nmapping = {}\nfor key, value in zip(key_list, value_list):\n    mapping[key] = value\n由于字典本质上是 2-元组的集合，因此 dict 函数接受 2-元组列表：\nIn [104]: tuples = zip(range(5), reversed(range(5)))\n\nIn [105]: tuples\nOut[105]: &lt;zip at 0x17d604d00&gt;\n\nIn [106]: mapping = dict(tuples)\n\nIn [107]: mapping\nOut[107]: {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}\n稍后我们将讨论字典推导式，这是构建字典的另一种方式。\nDefault values\n常见的逻辑如下：\nif key in some_dict:\n    value = some_dict[key]\nelse:\n    value = default_value\n因此，字典方法 get 和 pop 可以返回一个默认值，这样上面的 if-else 块就可以简单地写成：\nvalue = some_dict.get(key, default_value)\n如果键不存在，get 默认情况下将返回 None，而 pop 将引发异常。通过设置值，字典中的值可能是另一种集合，例如列表。例如，您可以想象将单词列表按其首字母分类为列表字典：\nIn [108]: words = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\n\nIn [109]: by_letter = {}\n\nIn [110]: for word in words:\n   .....:     letter = word[0]\n   .....:     if letter not in by_letter:\n   .....:         by_letter[letter] = [word]\n   .....:     else:\n   .....:         by_letter[letter].append(word)\n   .....:\n\nIn [111]: by_letter\nOut[111]: {'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\nsetdefault 字典方法可用于简化此工作流程。前面的 for 循环可以重写为：\nIn [112]: by_letter = {}\n\nIn [113]: for word in words:\n   .....:     letter = word[0]\n   .....:     by_letter.setdefault(letter, []).append(word)\n   .....:\n\nIn [114]: by_letter\nOut[114]: {'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n内置的 collections 模块有一个有用的类 defaultdict，这使得这变得更加容易。要创建一个，您可以传递一个类型或函数来为字典中的每个槽生成默认值：\nIn [115]: from collections import defaultdict\n\nIn [116]: by_letter = defaultdict(list)\n\nIn [117]: for word in words:\n   .....:     by_letter[word[0]].append(word)\nValid dictionary key types（有效的字典键类型）\n虽然字典的值可以是任何 Python 对象，但键通常必须是不可变对象，例如标量类型（int、float、string）或元组（元组中的所有对象也必须是不可变的）。这里的技术术语是可哈希性（hashability）。您可以使用 hash 函数检查对象是否可哈希（可以用作字典中的键）：\nIn [118]: hash(\"string\")\nOut[118]: 4022908869268713487\n\nIn [119]: hash((1, 2, (2, 3)))\nOut[119]: -9209053662355515447\n\nIn [120]: hash((1, 2, [2, 3])) # fails because lists are mutable\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-120-473c35a62c0b&gt; in &lt;module&gt;\n----&gt; 1 hash((1, 2, [2, 3])) # fails because lists are mutable\nTypeError: unhashable type: 'list'\n通常，您在使用 hash 函数时看到的哈希值取决于您所使用的 Python 版本。\n要使用列表作为键，一种选择是将其转换为元组，只要它的元素也可以是，就可以对其进行哈希处理：\nIn [121]: d = {}\n\nIn [122]: d[tuple([1, 2, 3])] = 5\n\nIn [123]: d\nOut[123]: {(1, 2, 3): 5}\n\n\n3.1.4 Set\n集合（set）是唯一元素的无序集合。可以通过两种方式创建集合：通过 set 函数或通过带花括号的集合文字：\nIn [124]: set([2, 2, 2, 1, 3, 3])\nOut[124]: {1, 2, 3}\n\nIn [125]: {2, 2, 2, 1, 3, 3}\nOut[125]: {1, 2, 3}\n集合支持数学集合运算，例如并集、交集、差值和对称差值。考虑这两个示例集：\nIn [126]: a = {1, 2, 3, 4, 5}\n\nIn [127]: b = {3, 4, 5, 6, 7, 8}\n这两个集合的并集是任一集合中出现的不同元素的集合。这可以使用 union 方法或 | 二元运算符来计算：\nIn [128]: a.union(b)\nOut[128]: {1, 2, 3, 4, 5, 6, 7, 8}\n\nIn [129]: a | b\nOut[129]: {1, 2, 3, 4, 5, 6, 7, 8}\n交集包含两个集合中出现的元素。可以使用 & 运算符或 intersection 方法：\nIn [130]: a.intersection(b)\nOut[130]: {3, 4, 5}\n\nIn [131]: a & b\nOut[131]: {3, 4, 5}\n有关常用设置方法的列表，请参阅 Table 3.1。\n\nTable 3.1: Python set operations\n\n\n\n\n\n\n\nFunction\nAlternative syntax\nDescription\n\n\n\n\na.add(x)\nN/A\n添加元素 x 到集合 a\n\n\na.clear()\nN/A\n重新设置 a 为空状态，丢弃其所有元素\n\n\na.remove(x)\nN/A\n从集合 a 中删除元素 x\n\n\na.pop()\nN/A\n从集合 a 中删除任意元素，如果集合为空则引发 KeyError\n\n\na.union(b)\na | b\na 和 b 的并集\n\n\na.update(b)\na |= b\n将 a 的内容设置为 a 和 b 的并集\n\n\na.intersection(b)\na & b\na 和 b 的交集\n\n\na.intersection_update(b)\na &= b\n将 a 的内容设置为 a 和 b 的交集\n\n\na.difference(b)\na - b\na 中有 b 中没有的元素\n\n\na.difference_update(b)\na -= b\n将 a 设置为 a 中有 b 中没有的元素\n\n\na.symmetric_difference(b)\na ^ b\na 或 b 中有，但不能同时存在的元素\n\n\na.symmetric_difference_update(b)\na ^= b\n将 a 设置为 a 或 b 中有，但不能同时存在的元素\n\n\na.issubset(b)\n&lt;=\n如果 a 的元素全部包含在 b 中，则为 True\n\n\na.issuperset(b)\n&gt;=\n如果 b 的元素全部包含在 a 中，则为 True\n\n\na.isdisjoint(b)\nN/A\n如果 a 和 b 没有共同元素，则为 True\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n如果将不是集合的输入传递给 union 和 intersection 等方法，Python 会在执行操作之前将输入转换为集合。使用二元运算符时，两个对象都必须已设置。\n\n\n所有逻辑集合操作都有就地对应项，这使您能够用结果替换操作左侧的集合内容。对于非常大的集合，这可能更有效：\nIn [132]: c = a.copy()\n\nIn [133]: c |= b\n\nIn [134]: c\nOut[134]: {1, 2, 3, 4, 5, 6, 7, 8}\n\nIn [135]: d = a.copy()\n\nIn [136]: d &= b\n\nIn [137]: d\nOut[137]: {3, 4, 5}\n与字典键一样，集合元素通常必须是不可变的，并且它们必须是可哈希的（hashable）（这意味着对值调用 hash 不会引发异常）。为了在集合中存储类似列表的元素（或其他可变序列），您可以将它们转换为元组：\nIn [138]: my_data = [1, 2, 3, 4]\n\nIn [139]: my_set = {tuple(my_data)}\n\nIn [140]: my_set\nOut[140]: {(1, 2, 3, 4)}\n您还可以检查一个集合是否是另一个集合的子集（包含在其中）或超集（包含其所有元素）：\nIn [141]: a_set = {1, 2, 3, 4, 5}\n\nIn [142]: {1, 2, 3}.issubset(a_set)\nOut[142]: True\n\nIn [143]: a_set.issuperset({1, 2, 3})\nOut[143]: True\n集合相等当且仅当它们的内容相等：\nIn [144]: {1, 2, 3} == {3, 2, 1}\nOut[144]: True\n\n\n3.1.5 Built-In Sequence Functions\nPython 有一些有用的序列函数，您应该熟悉它们并在任何机会使用它们。\nenumerate（枚举）\n在迭代序列时，通常希望跟踪当前项的索引。自己动手的方法如下所示：\nindex = 0\nfor value in collection:\n   # do something with value\n   index += 1\n由于这种情况很常见，Python 有一个内置函数 enumerate，它返回 (i, value) 元组序列：\nfor index, value in enumerate(collection):\n   # do something with value\nsorted（排序）\nsorted 函数从任何序列的元素中返回一个新的排序列表：\nIn [145]: sorted([7, 1, 2, 6, 0, 3, 2])\nOut[145]: [0, 1, 2, 2, 3, 6, 7]\n\nIn [146]: sorted(\"horse race\")\nOut[146]: [' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']\nsorted 函数接受与列表 sort 方法相同的参数。\nzip\nzip 将多个列表、元组或其他序列的元素“配对”以创建元组列表：\nIn [147]: seq1 = [\"foo\", \"bar\", \"baz\"]\n\nIn [148]: seq2 = [\"one\", \"two\", \"three\"]\n\nIn [149]: zipped = zip(seq1, seq2)\n\nIn [150]: list(zipped)\nOut[150]: [('foo', 'one'), ('bar', 'two'), ('baz', 'three')]\nzip 可以采用任意数量的序列，它产生的元素数量由最短序列决定：\nIn [151]: seq3 = [False, True]\n\nIn [152]: list(zip(seq1, seq2, seq3))\nOut[152]: [('foo', 'one', False), ('bar', 'two', True)]\nzip 的常见用法是同时迭代多个序列，也可能与 enumerate 结合使用：\nIn [153]: for index, (a, b) in enumerate(zip(seq1, seq2)):\n   .....:     print(f\"{index}: {a}, {b}\")\n   .....:\n0: foo, one\n1: bar, two\n2: baz, three\nreversed（倒序）\nreversed 以相反的顺序迭代序列的元素：\nIn [154]: list(reversed(range(10)))\nOut[154]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n请记住，reverse 是一个生成器（稍后将更详细地讨论），因此它不会创建反转序列，直到具体化（例如，使用 list 或 for 循环）。\n\n\n3.1.6 List, Set, and Dictionary Comprehensions\n列表推导式是一种方便且广泛使用的 Python 语言功能。它们允许您通过过滤集合的元素、将通过过滤器的元素转换为一个简洁的表达式来简洁地形成一个新列表。它们采用基本形式：\n[expr for value in collection if condition]\n这相当于以下 for 循环：\nresult = []\nfor value in collection:\n    if condition:\n        result.append(expr)\n过滤条件可以省略，只留下表达式。例如，给定一个字符串列表，我们可以过滤掉长度为 2 或更小的字符串，并将它们转换为大写，如下所示：\nIn [155]: strings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\n\nIn [156]: [x.upper() for x in strings if len(x) &gt; 2]\nOut[156]: ['BAT', 'CAR', 'DOVE', 'PYTHON']\n集合和字典推导式是一种自然的扩展，以惯用的类似方式而不是列表生成集合和字典。\n字典推导式如下所示：\ndict_comp = {key-expr: value-expr for value in collection\n             if condition}\n集合推导式看起来与等效的列表推导式相似，只是使用大括号而不是方括号：\nset_comp = {expr for value in collection if condition}\n与列表推导式一样，集合推导式和字典推导式大多都很方便，但它们同样可以使代码更易于编写和阅读。考虑之前的字符串列表。假设我们想要一个仅包含集合中字符串长度的集合；我们可以使用集合推导式轻松计算：\nIn [157]: unique_lengths = {len(x) for x in strings}\n\nIn [158]: unique_lengths\nOut[158]: {1, 2, 3, 4, 6}\n我们还可以使用稍后介绍的 map 函数来更功能地表达这一点：\nIn [159]: set(map(len, strings))\nOut[159]: {1, 2, 3, 4, 6}\n作为一个简单的字典推导式示例，我们可以创建这些字符串的查找映射以查找它们在列表中的位置：\nIn [160]: loc_mapping = {value: index for index, value in enumerate(strings)}\n\nIn [161]: loc_mapping\nOut[161]: {'a': 0, 'as': 1, 'bat': 2, 'car': 3, 'dove': 4, 'python': 5}\nNested list comprehensions（嵌套列表推导式）\n假设我们有一个包含一些英语和西班牙语名称的列表列表：\nIn [162]: all_data = [[\"John\", \"Emily\", \"Michael\", \"Mary\", \"Steven\"],\n   .....:             [\"Maria\", \"Juan\", \"Javier\", \"Natalia\", \"Pilar\"]]\n假设我们想要获取一个包含所有带有两个或多个 a 的名称的列表。我们当然可以通过一个简单的 for 循环来做到这一点：\nIn [163]: names_of_interest = []\n\nIn [164]: for names in all_data:\n   .....:     enough_as = [name for name in names if name.count(\"a\") &gt;= 2]\n   .....:     names_of_interest.extend(enough_as)\n   .....:\n\nIn [165]: names_of_interest\nOut[165]: ['Maria', 'Natalia']\n实际上，您可以将整个操作包装在单个嵌套列表推导式中，如下所示：\nIn [166]: result = [name for names in all_data for name in names\n   .....:           if name.count(\"a\") &gt;= 2]\n\nIn [167]: result\nOut[167]: ['Maria', 'Natalia']\n一开始，嵌套列表推导式有点难以理解。列表推导式的 for 部分按照嵌套顺序排列，任何过滤条件都像以前一样放在最后。这是另一个例子，我们将整数元组列表“展平（flatten）”为简单的整数列表：\nIn [168]: some_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n\nIn [169]: flattened = [x for tup in some_tuples for x in tup]\n\nIn [170]: flattened\nOut[170]: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n请记住，如果您编写嵌套的 for 循环而不是列表推导式，则 for 表达式的顺序将是相同的：\nflattened = []\n\nfor tup in some_tuples:\n    for x in tup:\n        flattened.append(x)\n您可以有任意多个嵌套级别，但如果您有超过两层或三层嵌套，您可能应该开始质疑从代码可读性的角度来看这是否有意义。区分刚刚显示的语法和列表推导式中的列表推导式非常重要，这也是完全有效的：\nIn [172]: [[x for x in tup] for tup in some_tuples]\nOut[172]: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n这会生成一个列表的列表，而不是所有内部元素的扁平列表。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Built-In Data Structures, Functions, and Files</span>"
    ]
  },
  {
    "objectID": "03.python-builtin.html#list",
    "href": "03.python-builtin.html#list",
    "title": "3  Built-In Data Structures, Functions, and Files",
    "section": "3.2 List",
    "text": "3.2 List",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Built-In Data Structures, Functions, and Files</span>"
    ]
  },
  {
    "objectID": "03.python-builtin.html#list-set-and-dictionary-comprehensions",
    "href": "03.python-builtin.html#list-set-and-dictionary-comprehensions",
    "title": "3  Built-In Data Structures, Functions, and Files",
    "section": "3.2 List, Set, and Dictionary Comprehensions",
    "text": "3.2 List, Set, and Dictionary Comprehensions",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Built-In Data Structures, Functions, and Files</span>"
    ]
  },
  {
    "objectID": "03.python-builtin.html#functions",
    "href": "03.python-builtin.html#functions",
    "title": "3  Built-In Data Structures, Functions, and Files",
    "section": "3.2 Functions",
    "text": "3.2 Functions\n函数是 Python 中代码组织和重用的主要也是最重要的方法。根据经验，如果您预计需要多次重复相同或非常相似的代码，那么编写可重用函数可能是值得的。函数还可以通过为一组 Python 语句命名来帮助提高代码的可读性。\n函数是用 def 关键字声明的。函数包含一个可以选择使用 return 关键字的代码块：\nIn [173]: def my_function(x, y):\n   .....:     return x + y\n当到达带有 return 的行时，return 后的值或表达式将被发送到调用该函数的上下文，例如：\nIn [174]: my_function(1, 2)\nOut[174]: 3\n\nIn [175]: result = my_function(1, 2)\n\nIn [176]: result\nOut[176]: 3\n有多个 return 语句没有问题。如果 Python 到达函数末尾而没有遇到 return 语句，则自动返回 None。例如：\nIn [177]: def function_without_return(x):\n   .....:     print(x)\n\nIn [178]: result = function_without_return(\"hello!\")\nhello!\n\nIn [179]: print(result)\nNone\n每个函数都可以有位置参数和关键字参数。关键字参数最常用于指定默认值或可选参数。这里我们将定义一个带有可选 z 参数的函数，默认值为 1.5：\ndef my_function2(x, y, z=1.5):\n    if z &gt; 1:\n        return z * (x + y)\n    else:\n        return z / (x + y)\n虽然关键字参数是可选的，但在调用函数时必须指定所有位置参数。\n您可以将值传递给 z 参数，无论是否提供关键字，但鼓励使用关键字：\nIn [181]: my_function2(5, 6, z=0.7)\nOut[181]: 0.06363636363636363\n\nIn [182]: my_function2(3.14, 7, 3.5)\nOut[182]: 35.49\n\nIn [183]: my_function2(10, 20)\nOut[183]: 45.0\n对函数参数的主要限制是关键字参数必须位于位置参数（如果有）之后。您可以按任意顺序指定关键字参数。这使您不必记住指定函数参数的顺序。您只需记住他们的名字即可。\n\n3.2.1 Namespaces, Scope, and Local Functions\n函数可以访问在函数内部创建的变量以及在更高（甚至全局）范围内的函数外部创建的变量。在 Python 中描述变量作用域的另一个更具描述性的名称是命名空间(namespace)。默认情况下，在函数内分配的任何变量都会分配给本地命名空间。本地命名空间是在调用函数时创建的，并立即由函数的参数填充。函数完成后，本地名称空间将被销毁（有一些例外情况超出了本章的范围）。考虑以下函数：\ndef func():\n    a = []\n    for i in range(5):\n        a.append(i)\n当调用 func() 时，会创建空列表 a，添加五个元素，然后在函数退出时销毁 a。假设我们声明了 a 如下：\nIn [184]: a = []\n\nIn [185]: def func():\n   .....:     for i in range(5):\n   .....:         a.append(i)\n每次调用 func 都会修改列表 a：\nIn [186]: func()\n\nIn [187]: a\nOut[187]: [0, 1, 2, 3, 4]\n\nIn [188]: func()\n\nIn [189]: a\nOut[189]: [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n可以在函数范围之外分配变量，但必须使用 global 或 nonlocal 关键字显式声明这些变量：\nIn [190]: a = None\n\nIn [191]: def bind_a_variable():\n   .....:     global a\n   .....:     a = []\n   .....: bind_a_variable()\n   .....:\n\nIn [192]: print(a)\n[]\nnonlocal 允许函数修改在非全局的更高级别范围中定义的变量。由于它的使用有些深奥（我在本书中从未使用过它），因此我建议您参阅 Python 文档以了解更多信息。\n\n\n\n\n\n\nCaution\n\n\n\n我通常不鼓励使用 global 关键字。通常，全局变量用于存储系统中的某种状态。如果您发现自己使用了很多它们，则可能表明需要面向对象编程（使用类）。\n\n\n\n\n3.2.2 Returning Multiple Values\n当我在使用 Java 和 C++ 编程后第一次使用 Python 编程时，我最喜欢的功能之一是能够使用简单的语法从函数返回多个值。这是一个例子：\ndef f():\n    a = 5\n    b = 6\n    c = 7\n    return a, b, c\n\na, b, c = f()\n在数据分析和其他科学应用中，您可能会发现自己经常这样做。这里发生的情况是，该函数实际上只是返回一个对象，一个元组，然后将其解压缩到结果变量中。在前面的示例中，我们可以这样做：\nreturn_value = f()\n在这种情况下，return_value 将是一个包含三个返回变量的三元组。像以前一样返回多个值的一个潜在有吸引力的替代方案可能是返回一个字典：\ndef f():\n    a = 5\n    b = 6\n    c = 7\n    return {\"a\" : a, \"b\" : b, \"c\" : c}\n这种替代技术可能会很有用，具体取决于您想要做什么。\n\n\n3.2.3 Functions Are Objects\n由于 Python 函数是对象，因此可以轻松表达许多在其他语言中难以做到的结构。假设我们正在进行一些数据清理，并且需要对以下字符串列表应用一系列转换：\nIn [193]: states = [\"   Alabama \", \"Georgia!\", \"Georgia\", \"georgia\", \"FlOrIda\",\n   .....:           \"south   carolina##\", \"West virginia?\"]\n任何曾经处理过用户提交的调查数据的人都见过这样混乱的结果。为了使这个字符串列表统一并准备好进行分析，需要做很多事情：去除空格、删除标点符号以及标准化正确的大写。一种方法是使用内置字符串方法以及正则表达式的 re 标准库模块：\nimport re\n\ndef clean_strings(strings):\n    result = []\n    for value in strings:\n        value = value.strip()\n        value = re.sub(\"[!#?]\", \"\", value)\n        value = value.title()\n        result.append(value)\n    return result\n结果如下：\nIn [195]: clean_strings(states)\nOut[195]: \n['Alabama',\n 'Georgia',\n 'Georgia',\n 'Georgia',\n 'Florida',\n 'South   Carolina',\n 'West Virginia']\n您可能会发现有用的另一种方法是列出要应用于特定字符串集的操作：\ndef remove_punctuation(value):\n    return re.sub(\"[!#?]\", \"\", value)\n\nclean_ops = [str.strip, remove_punctuation, str.title]\n\ndef clean_strings(strings, ops):\n    result = []\n    for value in strings:\n        for func in ops:\n            value = func(value)\n        result.append(value)\n    return result\n然后我们有以下内容：\nIn [197]: clean_strings(states, clean_ops)\nOut[197]: \n['Alabama',\n 'Georgia',\n 'Georgia',\n 'Georgia',\n 'Florida',\n 'South   Carolina',\n 'West Virginia']\n像这样的更实用的模式使您能够轻松地在非常高的级别上修改字符串的转换方式。 clean_strings 函数现在也更加可重用和通用。\n您可以使用函数作为其他函数的参数，例如内置的映射函数，它将函数应用于某种序列：\nIn [198]: for x in map(remove_punctuation, states):\n   .....:     print(x)\nAlabama \nGeorgia\nGeorgia\ngeorgia\nFlOrIda\nsouth   carolina\nWest virginia\nmap 可以用作列表推导式的替代方案，无需任何过滤器。\n\n\n3.2.4 Anonymous (Lambda) Functions\nPython 支持所谓的匿名函数(anonymous)或 lambda 函数，它们是一种编写由单个语句组成的函数的方法，其结果是返回值。它们是用 lambda 关键字定义的，除了“我们正在声明一个匿名函数”之外没有任何意义：\nIn [199]: def short_function(x):\n   .....:     return x * 2\n\nIn [200]: equiv_anon = lambda x: x * 2\n在本书的其余部分中，我通常将这些称为 lambda 函数。它们在数据分析中特别方便，因为正如您将看到的，在很多情况下数据转换函数将函数作为参数。与编写完整的函数声明甚至将 lambda 函数分配给局部变量相比，传递 lambda 函数通常需要更少的输入（并且更清晰）。考虑这个例子：\nIn [201]: def apply_to_list(some_list, f):\n   .....:     return [f(x) for x in some_list]\n\nIn [202]: ints = [4, 0, 1, 5, 6]\n\nIn [203]: apply_to_list(ints, lambda x: x * 2)\nOut[203]: [8, 0, 2, 10, 12]\n您也可以编写 [x * 2 for x in ints]，但在这里我们能够简洁地将自定义运算符传递给 apply_to_list 函数。\n再举一个例子，假设您想按每个字符串中不同字母的数量对字符串集合进行排序：\nIn [204]: strings = [\"foo\", \"card\", \"bar\", \"aaaa\", \"abab\"]\n这里我们可以将 lambda 函数传递给列表的 sort 方法：\nIn [205]: strings.sort(key=lambda x: len(set(x)))\n\nIn [206]: strings\nOut[206]: ['aaaa', 'foo', 'abab', 'bar', 'card']\n\n\n3.2.5 Generators\nPython 中的许多对象都支持迭代，例如列表中的对象或文件中的行。这是通过迭代器协议来完成的，迭代器协议是使对象可迭代的通用方法。例如，迭代字典会产生字典键：\nIn [207]: some_dict = {\"a\": 1, \"b\": 2, \"c\": 3}\n\nIn [208]: for key in some_dict:\n   .....:     print(key)\na\nb\nc\n当您写入 for key in some_dict 时，Python 解释器首先尝试从 some_dict 创建一个迭代器：\nIn [209]: dict_iterator = iter(some_dict)\n\nIn [210]: dict_iterator\nOut[210]: &lt;dict_keyiterator at 0x17d60e020&gt;\n迭代器是在 for 循环等上下文中使用时将向 Python 解释器生成对象的任何对象。大多数需要列表或类列表对象的方法也将接受任何可迭代对象。这包括内置方法（例如 min、max 和 sum）以及类型构造函数（例如 list 和 tuple）：\nIn [211]: list(dict_iterator)\nOut[211]: ['a', 'b', 'c']\n生成器(generator)是一种构造新的可迭代对象的便捷方法，类似于编写普通函数。普通函数一次执行并返回一个结果，而生成器可以通过每次使用生成器时暂停和恢复执行来返回多个值的序列。要创建生成器，请在函数中使用 yield 关键字而不是 return：\ndef squares(n=10):\n    print(f\"Generating squares from 1 to {n ** 2}\")\n    for i in range(1, n + 1):\n        yield i ** 2\n当您实际调用生成器时，不会立即执行任何代码：\nIn [213]: gen = squares()\n\nIn [214]: gen\nOut[214]: &lt;generator object squares at 0x17d5fea40&gt;\n直到您从生成器请求元素后，它才开始执行其代码：\nIn [215]: for x in gen:\n   .....:     print(x, end=\" \")\nGenerating squares from 1 to 100\n1 4 9 16 25 36 49 64 81 100\n\n\n\n\n\n\nNote\n\n\n\n由于生成器一次生成一个元素而不是一次生成整个列表，因此它可以帮助您的程序使用更少的内存。\n\n\nGenerator expressions\n制作生成器的另一种方法是使用生成器表达式。这是一个类似于列表、字典和集合推导式的生成器。要创建一个，请将本来是列表理解的内容括在括号而不是方括号内：\nIn [216]: gen = (x ** 2 for x in range(100))\n\nIn [217]: gen\nOut[217]: &lt;generator object &lt;genexpr&gt; at 0x17d5feff0&gt;\n这相当于以下更详细的生成器：\ndef _make_gen():\n    for x in range(100):\n        yield x ** 2\ngen = _make_gen()\n在某些情况下，可以使用生成器表达式代替列表推导式作为函数参数：\nIn [218]: sum(x ** 2 for x in range(100))\nOut[218]: 328350\n\nIn [219]: dict((i, i ** 2) for i in range(5))\nOut[219]: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n根据理解表达式生成的元素数量，生成器版本有时可能会更快。\nitertools module\n标准库 itertools 模块包含许多常见数据算法的生成器集合。例如，groupby 接受任何序列和一个函数，根据函数的返回值对序列中的连续元素进行分组。这是一个例子：\nIn [220]: import itertools\n\nIn [221]: def first_letter(x):\n   .....:     return x[0]\n\nIn [222]: names = [\"Alan\", \"Adam\", \"Wes\", \"Will\", \"Albert\", \"Steven\"]\n\nIn [223]: for letter, names in itertools.groupby(names, first_letter):\n   .....:     print(letter, list(names)) # names is a generator\nA ['Alan', 'Adam']\nW ['Wes', 'Will']\nA ['Albert']\nS ['Steven']\n请参阅 Table 3.2，了解我经常发现有用的其他一些 itertools 函数的列表。您可能想查看 the official Python documentation，了解有关这个有用的内置实用程序模块的更多信息。\n\nTable 3.2: Some useful itertools functions\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nchain(*iterables)\n通过将迭代器链接在一起生成序列。一旦第一个迭代器中的元素耗尽，就会返回下一个迭代器中的元素，依此类推。\n\n\ncombinations(iterable, k)\n以可迭代的方式生成所有可能的 k 元组元素的序列，忽略顺序且不进行替换（另请参阅配套函数 Combinations_with_replacement）。\n\n\npermutations(iterable, k)\n以可迭代、尊重的顺序生成所有可能的 k 元组元素的序列。\n\n\ngroupby(iterable[, keyfunc])\n为每个唯一键生成（键，子迭代器）。\n\n\nproduct(*iterables, repeat=1)\n将输入可迭代对象的笛卡尔积生成为元组，类似于嵌套的 for 循环。\n\n\n\n\n\n3.2.6 Errors and Exception Handling\n优雅地处理 Python 错误或异常是构建健壮程序的重要组成部分。在数据分析应用程序中，许多函数仅适用于某些类型的输入。例如，Python 的 float 函数能够将字符串转换为浮点数，但在输入不正确时会失败并出现 ValueError：\nIn [224]: float(\"1.2345\")\nOut[224]: 1.2345\n\nIn [225]: float(\"something\")\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-225-5ccfe07933f4&gt; in &lt;module&gt;\n----&gt; 1 float(\"something\")\nValueError: could not convert string to float: 'something'\n假设我们想要一个能够正常失败并返回输入参数的 float 版本。我们可以通过编写一个函数来实现这一点，该函数将对 float 的调用封装在 try/except 块中（在 IPython 中执行此代码）：\ndef attempt_float(x):\n    try:\n        return float(x)\n    except:\n        return x\n仅当 float(x) 引发异常时才会执行该块的 except 部分中的代码：\nIn [227]: attempt_float(\"1.2345\")\nOut[227]: 1.2345\n\nIn [228]: attempt_float(\"something\")\nOut[228]: 'something'\n您可能会注意到 float 可以引发 ValueError 以外的异常：\nIn [229]: float((1, 2))\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-229-82f777b0e564&gt; in &lt;module&gt;\n----&gt; 1 float((1, 2))\nTypeError: float() argument must be a string or a real number, not 'tuple'\n您可能只想抑制 ValueError，因为 TypeError（输入不是字符串或数值）可能表明程序中存在合法错误。为此，请在 except 后面写入异常类型：\ndef attempt_float(x):\n    try:\n        return float(x)\n    except ValueError:\n        return x\n那么我们有：\nIn [231]: attempt_float((1, 2))\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-231-8b0026e9e6b7&gt; in &lt;module&gt;\n----&gt; 1 attempt_float((1, 2))\n&lt;ipython-input-230-6209ddecd2b5&gt; in attempt_float(x)\n      1 def attempt_float(x):\n      2     try:\n----&gt; 3         return float(x)\n      4     except ValueError:\n      5         return x\nTypeError: float() argument must be a string or a real number, not 'tuple'\n您可以通过编写异常类型的元组来捕获多个异常类型（括号是必需的）：\ndef attempt_float(x):\n    try:\n        return float(x)\n    except (TypeError, ValueError):\n        return x\n在某些情况下，您可能不想抑制异常，但希望无论 try 块中的代码是否成功都执行某些代码。为此，请使用 finally：\nf = open(path, mode=\"w\")\n\ntry:\n    write_to_file(f)\nfinally:\n    f.close()\n在这里，文件对象 f 将始终被关闭。类似地，您可以使用 else 使代码仅在 try: 块成功时才执行：\nf = open(path, mode=\"w\")\n\ntry:\n    write_to_file(f)\nexcept:\n    print(\"Failed\")\nelse:\n    print(\"Succeeded\")\nfinally:\n    f.close()\nExceptions in IPython\n如果在运行脚本或执行任何语句时引发异常，IPython 默认情况下将打印完整的调用堆栈跟踪（traceback），其中包含堆栈中每个点位置周围的几行上下文：\nIn [10]: %run examples/ipython_bug.py\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\n/home/wesm/code/pydata-book/examples/ipython_bug.py in &lt;module&gt;()\n     13     throws_an_exception()\n     14\n---&gt; 15 calling_things()\n\n/home/wesm/code/pydata-book/examples/ipython_bug.py in calling_things()\n     11 def calling_things():\n     12     works_fine()\n---&gt; 13     throws_an_exception()\n     14\n     15 calling_things()\n\n/home/wesm/code/pydata-book/examples/ipython_bug.py in throws_an_exception()\n      7     a = 5\n      8     b = 6\n----&gt; 9     assert(a + b == 10)\n     10\n     11 def calling_things():\n\nAssertionError:\n与标准 Python 解释器（不提供任何附加上下文）相比，拥有附加上下文本身是一个很大的优势。您可以使用 %xmode 魔术命令控制显示的上下文量，从 Plain（与标准 Python 解释器相同）到 Verbose（内联函数参数值等）。正如您稍后将在 Appendix B: More on the IPython System 中看到的那样，您可以在发生错误后进入堆栈（使用 %debug 或 %pdb 魔法）进行交互式事后调试。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Built-In Data Structures, Functions, and Files</span>"
    ]
  },
  {
    "objectID": "03.python-builtin.html#files-and-the-operating-system",
    "href": "03.python-builtin.html#files-and-the-operating-system",
    "title": "3  Built-In Data Structures, Functions, and Files",
    "section": "3.3 Files and the Operating System",
    "text": "3.3 Files and the Operating System\n本书的大部分内容都使用 pandas.read_csv 等高级工具将数据文件从磁盘读取到 Python 数据结构中。然而，了解如何在 Python 中使用文件的基础知识非常重要。幸运的是，它相对简单，这也是 Python 在文本和文件修改方面如此流行的原因之一。\n要打开文件进行读取或写入，请使用带有相对或绝对文件路径和可选文件编码的内置 open 函数：\nIn [233]: path = \"examples/segismundo.txt\"\n\nIn [234]: f = open(path, encoding=\"utf-8\")\n在这里，我将encoding=\"utf-8\"作为最佳实践，因为读取文件的默认 Unicode 编码因平台而异。\n默认情况下，文件以只读模式\"r\"打开。然后我们可以将文件对象 f 视为列表并迭代各行，如下所示：\nfor line in f:\n    print(line)\n这些行从文件中出来时，行尾 (EOL) 标记完好无损，因此您经常会看到在文件中获取无 EOL 行列表的代码，例如：\nIn [235]: lines = [x.rstrip() for x in open(path, encoding=\"utf-8\")]\n\nIn [236]: lines\nOut[236]: \n['Sueña el rico en su riqueza,',\n 'que más cuidados le ofrece;',\n '',\n 'sueña el pobre que padece',\n 'su miseria y su pobreza;',\n '',\n 'sueña el que a medrar empieza,',\n 'sueña el que afana y pretende,',\n 'sueña el que agravia y ofende,',\n '',\n 'y en el mundo, en conclusión,',\n 'todos sueñan lo que son,',\n 'aunque ninguno lo entiende.',\n '']\n当您使用 open 创建文件对象时，建议在使用完毕后关闭该文件。关闭文件会将其资源释放回操作系统：\nIn [237]: f.close()\n更轻松地清理打开的文件的方法之一是使用 with 语句：\nIn [238]: with open(path, encoding=\"utf-8\") as f:\n   .....:     lines = [x.rstrip() for x in f]\n这将在退出 with 块时自动关闭文件 f。无法确保文件关闭不会在许多小程序或脚本中导致问题，但在需要与大量文件交互的程序中可能会出现问题。\n如果我们输入 f = open(path, \"w\")，则会在 Examples/segismundo.txt 中创建一个新文件（小心！），覆盖其位置上的任何文件。还有\"x\"文件模式，它创建一个可写文件，但如果文件路径已经存在则失败。有关所有有效文件读/写模式的列表，请参阅 Table 3.3。\n\nTable 3.3: Python file modes\n\n\n\n\n\n\nMode\nDescription\n\n\n\n\nr\n只读模式\n\n\nw\n只写模式；创建一个新文件（删除任何同名文件的数据）\n\n\nx\n只写模式；创建新文件，但如果文件路径已存在则失败\n\n\na\n追加到现有文件（如果文件尚不存在则创建该文件）\n\n\nr+\n读和写\n\n\nb\n添加到二进制文件的模式（即\"rb\"或\"wb\"）\n\n\nt\n文件的文本模式（自动将字节解码为 Unicode）；如果未指定，则这是默认值\n\n\n\n对于可读文件，最常用的一些方法是 read、seek 和 tell。read 从文件中返回一定数量的字符。“字符”的构成由文件编码决定，如果文件以二进制模式打开，则由原始字节决定：\nIn [239]: f1 = open(path)\n\nIn [240]: f1.read(10)\nOut[240]: 'Sueña el r'\n\nIn [241]: f2 = open(path, mode=\"rb\")  # Binary mode\n\nIn [242]: f2.read(10)\nOut[242]: b'Sue\\xc3\\xb1a el '\nread 方法将文件对象位置前进所读取的字节数。告诉你当前的位置：\nIn [243]: f1.tell()\nOut[243]: 11\n\nIn [244]: f2.tell()\nOut[244]: 10\n即使我们从以文本模式打开的文件 f1 中读取了 10 个字符，位置也是 11，因为使用默认编码解码 10 个字符需要那么多字节。您可以检查 sys 模块中的默认编码：\nIn [245]: import sys\n\nIn [246]: sys.getdefaultencoding()\nOut[246]: 'utf-8'\n为了获得跨平台的一致行为，最好在打开文件时传递编码（例如广泛使用的encoding =\"utf-8\"）。\nseek 将文件位置更改为文件中指定的字节：\nIn [247]: f1.seek(3)\nOut[247]: 3\n\nIn [248]: f1.read(1)\nOut[248]: 'ñ'\n\nIn [249]: f1.tell()\nOut[249]: 5\n最后，我们记得关闭文件：\nIn [250]: f1.close()\n\nIn [251]: f2.close()\n要将文本写入文件，可以使用文件的 write 或 writelines 方法。例如，我们可以创建一个没有空行的 example/segismundo.txt 版本，如下所示：\nIn [252]: path\nOut[252]: 'examples/segismundo.txt'\n\nIn [253]: with open(\"tmp.txt\", mode=\"w\") as handle:\n   .....:     handle.writelines(x for x in open(path) if len(x) &gt; 1)\n\nIn [254]: with open(\"tmp.txt\") as f:\n   .....:     lines = f.readlines()\n\nIn [255]: lines\nOut[255]: \n['Sueña el rico en su riqueza,\\n',\n 'que más cuidados le ofrece;\\n',\n 'sueña el pobre que padece\\n',\n 'su miseria y su pobreza;\\n',\n 'sueña el que a medrar empieza,\\n',\n 'sueña el que afana y pretende,\\n',\n 'sueña el que agravia y ofende,\\n',\n 'y en el mundo, en conclusión,\\n',\n 'todos sueñan lo que son,\\n',\n 'aunque ninguno lo entiende.\\n']\n有关许多最常用的文件方法，请参阅 Table 3.4。\n\nTable 3.4: Important Python file methods or attributes\n\n\n\n\n\n\nMethod/attribute\nDescription\n\n\n\n\nread([size])\n根据文件模式以字节或字符串形式从文件返回数据，可选 size 参数指示要读取的字节数或字符串字符数\n\n\nreadable()\n如果文件支持 read 操作则返回 True\n\n\nreadlines([size])\n返回文件中的行列表，带有可选的 size 参数\n\n\nwrite(string)\n将传递的字符串写入文件\n\n\nwritable()\n如果文件支持 write 操作则返回 True\n\n\nwritelines(strings)\n将传递的字符串序列写入文件\n\n\nclose()\n关闭文件对象\n\n\nflush()\n将内部 I/O 缓冲区刷新到磁盘\n\n\nseek(pos)\n移动到指定的文件位置（整数）\n\n\nseekable()\n如果文件对象支持查找并因此支持随机访问（某些类似文件的对象不支持），则返回 True\n\n\ntell()\n以整数形式返回当前文件位置\n\n\nclosed\n如果文件已关闭则为 True\n\n\nencoding\n用于将文件中的字节解释为 Unicode（通常为 UTF-8）的编码\n\n\n\n\n3.3.1 Bytes and Unicode with Files\nPython 文件的默认行为（无论是可读还是可写）是文本模式，这意味着您打算使用 Python 字符串（即 Unicode）。这与二进制模式形成对比，您可以通过将 b 附加到文件模式来获得二进制模式。重新访问上一节中的文件（其中包含采用 UTF-8 编码的非 ASCII 字符），我们有：\nIn [258]: with open(path) as f:\n   .....:     chars = f.read(10)\n\nIn [259]: chars\nOut[259]: 'Sueña el r'\n\nIn [260]: len(chars)\nOut[260]: 10\nUTF-8 是一种可变长度的 Unicode 编码，因此当我从文件中请求一定数量的字符时，Python 会从文件中读取足够的字节（可能少至 10 个字节，也可能多至 40 个字节）来解码那么多字符。如果我以\"rb\"模式打开文件，则读取请求的确切字节数：\nIn [261]: with open(path, mode=\"rb\") as f:\n   .....:     data = f.read(10)\n\nIn [262]: data\nOut[262]: b'Sue\\xc3\\xb1a el '\n根据文本编码，您可以自己将字节解码为 str 对象，但前提是每个编码的 Unicode 字符都完全形成：\nIn [263]: data.decode(\"utf-8\")\nOut[263]: 'Sueña el '\n\nIn [264]: data[:4].decode(\"utf-8\")\n---------------------------------------------------------------------------\nUnicodeDecodeError                        Traceback (most recent call last)\n&lt;ipython-input-264-846a5c2fed34&gt; in &lt;module&gt;\n----&gt; 1 data[:4].decode(\"utf-8\")\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xc3 in position 3: unexpecte\nd end of data\n文本模式与 open 的 encoding 选项相结合，提供了一种从一种 Unicode 编码转换为另一种编码的便捷方法：\nIn [265]: sink_path = \"sink.txt\"\n\nIn [266]: with open(path) as source:\n   .....:     with open(sink_path, \"x\", encoding=\"iso-8859-1\") as sink:\n   .....:         sink.write(source.read())\n\nIn [267]: with open(sink_path, encoding=\"iso-8859-1\") as f:\n   .....:     print(f.read(10))\nSueña el r\n以二进制以外的任何模式打开文件时请注意使用 seek。如果文件位置位于定义 Unicode 字符的字节中间，则后续读取将导致错误：\nIn [269]: f = open(path, encoding='utf-8')\n\nIn [270]: f.read(5)\nOut[270]: 'Sueña'\n\nIn [271]: f.seek(4)\nOut[271]: 4\n\nIn [272]: f.read(1)\n---------------------------------------------------------------------------\nUnicodeDecodeError                        Traceback (most recent call last)\n&lt;ipython-input-272-5a354f952aa4&gt; in &lt;module&gt;\n----&gt; 1 f.read(1)\n~/miniforge-x86/envs/book-env/lib/python3.10/codecs.py in decode(self, input, fin\nal)\n    320         # decode input (taking the buffer into account)\n    321         data = self.buffer + input\n--&gt; 322         (result, consumed) = self._buffer_decode(data, self.errors, final\n)\n    323         # keep undecoded input until the next call\n    324         self.buffer = data[consumed:]\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xb1 in position 0: invalid s\ntart byte\n\nIn [273]: f.close()\n如果您发现自己经常对 non-ASCII 文本数据进行数据分析，那么掌握 Python 的 Unicode 功能将非常有价值。有关更多信息，请参阅 Python’s online documentation。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Built-In Data Structures, Functions, and Files</span>"
    ]
  },
  {
    "objectID": "03.python-builtin.html#conclusion",
    "href": "03.python-builtin.html#conclusion",
    "title": "3  Built-In Data Structures, Functions, and Files",
    "section": "3.4 Conclusion",
    "text": "3.4 Conclusion\n现在您已经掌握了 Python 环境和语言的一些基础知识，是时候继续学习 NumPy 和 Python 中面向数组的计算了。",
    "crumbs": [
      "Chapters",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Built-In Data Structures, Functions, and Files</span>"
    ]
  }
]